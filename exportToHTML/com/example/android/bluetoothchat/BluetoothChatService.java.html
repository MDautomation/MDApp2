<html>
<head>
<title>BluetoothChatService.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(204,120,50); }
.s3 { color: rgb(98,151,85); }
.s4 { color: rgb(128,128,128); }
.s5 { color: rgb(106,135,89); }
.s6 { color: rgb(104,151,187); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
BluetoothChatService.java</FONT>
</center></TD></TR></TABLE>
<pre>

<span class="s0">/* 
 * Copyright (C) 2014 The Android Open Source Project 
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 */</span><span class="s1"> 
 
</span><span class="s2">package </span><span class="s1">com.example.android.bluetoothchat</span><span class="s2">;</span><span class="s1"> 
 
</span><span class="s2">import </span><span class="s1">android.bluetooth.BluetoothAdapter</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.bluetooth.BluetoothDevice</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.bluetooth.BluetoothServerSocket</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.bluetooth.BluetoothSocket</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.content.Context</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.os.Bundle</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.os.Handler</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">android.os.Message</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">com.example.android.common.logger.Log</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.io.IOException</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.io.InputStream</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.io.OutputStream</span><span class="s2">;</span><span class="s1"> 
</span><span class="s2">import </span><span class="s1">java.util.UUID</span><span class="s2">;</span><span class="s1"> 
 
</span><span class="s3">/** 
 * This class does all the work for setting up and managing Bluetooth 
 * connections with other devices. It has a thread that listens for 
 * incoming connections, a thread for connecting with a device, and a 
 * thread for performing data transmissions when connected. 
 */</span><span class="s1"> 
</span><span class="s2">public class </span><span class="s1">BluetoothChatService { 
    </span><span class="s4">// Debugging</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">String TAG = </span><span class="s5">&quot;BluetoothChatService&quot;</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s4">// Name for the SDP record when creating server socket</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">String NAME_SECURE = </span><span class="s5">&quot;BluetoothChatSecure&quot;</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">String NAME_INSECURE = </span><span class="s5">&quot;BluetoothChatInsecure&quot;</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s4">// Unique UUID for this application</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">UUID MY_UUID_SECURE = 
            UUID.fromString(</span><span class="s5">&quot;00001101-0000-1000-8000-00805F9B34FB&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private static final </span><span class="s1">UUID MY_UUID_INSECURE = 
            UUID.fromString(</span><span class="s5">&quot;00001101-0000-1000-8000-00805F9B34FB&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s4">//   UUID.fromString(&quot;8ce255c0-200a-11e0-ac64-0800200c9a66&quot;);</span><span class="s1"> 
    </span><span class="s4">// Member fields</span><span class="s1"> 
    </span><span class="s2">private final </span><span class="s1">BluetoothAdapter mAdapter</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private final </span><span class="s1">Handler mHandler</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">AcceptThread mSecureAcceptThread</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">AcceptThread mInsecureAcceptThread</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">ConnectThread mConnectThread</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private </span><span class="s1">ConnectedThread mConnectedThread</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s2">private int </span><span class="s1">mState</span><span class="s2">;</span><span class="s1"> 
 
    </span><span class="s4">// Constants that indicate the current connection state</span><span class="s1"> 
    </span><span class="s2">public static final int </span><span class="s1">STATE_NONE = </span><span class="s6">0</span><span class="s2">;       </span><span class="s4">// we're doing nothing</span><span class="s1"> 
    </span><span class="s2">public static final int </span><span class="s1">STATE_LISTEN = </span><span class="s6">1</span><span class="s2">;     </span><span class="s4">// now listening for incoming connections</span><span class="s1"> 
    </span><span class="s2">public static final int </span><span class="s1">STATE_CONNECTING = </span><span class="s6">2</span><span class="s2">; </span><span class="s4">// now initiating an outgoing connection</span><span class="s1"> 
    </span><span class="s2">public static final int </span><span class="s1">STATE_CONNECTED = </span><span class="s6">3</span><span class="s2">;  </span><span class="s4">// now connected to a remote device</span><span class="s1"> 
 
    </span><span class="s2">private </span><span class="s1">String newVar</span><span class="s2">;</span><span class="s1"> 
    </span><span class="s3">/** 
     * Constructor. Prepares a new BluetoothChat session. 
     * 
     * @param context The UI Activity Context 
     * @param handler A Handler to send messages back to the UI Activity 
     */</span><span class="s1"> 
    </span><span class="s2">public </span><span class="s1">BluetoothChatService(Context context</span><span class="s2">, </span><span class="s1">Handler handler) { 
        mAdapter = BluetoothAdapter.getDefaultAdapter()</span><span class="s2">;</span><span class="s1"> 
        mState = STATE_NONE</span><span class="s2">;</span><span class="s1"> 
        mHandler = handler</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Set the current state of the chat connection 
     * 
     * @param state An integer defining the current connection state 
     */</span><span class="s1"> 
    </span><span class="s2">private synchronized void </span><span class="s1">setState(</span><span class="s2">int </span><span class="s1">state) { 
        Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;setState() &quot; </span><span class="s1">+ mState + </span><span class="s5">&quot; -&gt; &quot; </span><span class="s1">+ state)</span><span class="s2">;</span><span class="s1"> 
        mState = state</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Give the new state to the Handler so the UI Activity can update</span><span class="s1"> 
        mHandler.obtainMessage(Constants.MESSAGE_STATE_CHANGE</span><span class="s2">, </span><span class="s1">state</span><span class="s2">, </span><span class="s1">-</span><span class="s6">1</span><span class="s1">).sendToTarget()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Return the current connection state. 
     */</span><span class="s1"> 
    </span><span class="s2">public synchronized int </span><span class="s1">getState() { 
        </span><span class="s2">return </span><span class="s1">mState</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Start the chat service. Specifically start AcceptThread to begin a 
     * session in listening (server) mode. Called by the Activity onResume() 
     */</span><span class="s1"> 
 
    </span><span class="s2">public synchronized void </span><span class="s1">start() { 
        Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Cancel any thread attempting to make a connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mConnectThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s4">// Cancel any thread currently running a connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mConnectedThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectedThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectedThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        setState(STATE_LISTEN)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Start the thread to listen on a BluetoothServerSocket</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mSecureAcceptThread == </span><span class="s2">null</span><span class="s1">) { 
            mSecureAcceptThread = </span><span class="s2">new </span><span class="s1">AcceptThread(</span><span class="s2">true</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            mSecureAcceptThread.start()</span><span class="s2">;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">(mInsecureAcceptThread == </span><span class="s2">null</span><span class="s1">) { 
            mInsecureAcceptThread = </span><span class="s2">new </span><span class="s1">AcceptThread(</span><span class="s2">false</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            mInsecureAcceptThread.start()</span><span class="s2">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s3">/** 
     * Start the ConnectThread to initiate a connection to a remote device. 
     * 
     * @param device The BluetoothDevice to connect 
     * @param secure Socket Security type - Secure (true) , Insecure (false) 
     */</span><span class="s1"> 
    </span><span class="s2">public synchronized void </span><span class="s1">connect(BluetoothDevice device</span><span class="s2">, boolean </span><span class="s1">secure) { 
        Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;connect to: &quot; </span><span class="s1">+ device)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Cancel any thread attempting to make a connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mState == STATE_CONNECTING) { 
            </span><span class="s2">if </span><span class="s1">(mConnectThread != </span><span class="s2">null</span><span class="s1">) { 
                mConnectThread.cancel()</span><span class="s2">;</span><span class="s1"> 
                mConnectThread = </span><span class="s2">null;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s4">// Cancel any thread currently running a connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mConnectedThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectedThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectedThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s4">// Start the thread to connect with the given device</span><span class="s1"> 
        mConnectThread = </span><span class="s2">new </span><span class="s1">ConnectThread(device</span><span class="s2">, </span><span class="s1">secure)</span><span class="s2">;</span><span class="s1"> 
        mConnectThread.start()</span><span class="s2">;</span><span class="s1"> 
        setState(STATE_CONNECTING)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Start the ConnectedThread to begin managing a Bluetooth connection 
     * 
     * @param socket The BluetoothSocket on which the connection was made 
     * @param device The BluetoothDevice that has been connected 
     */</span><span class="s1"> 
    </span><span class="s2">public synchronized void </span><span class="s1">connected(BluetoothSocket socket</span><span class="s2">, </span><span class="s1">BluetoothDevice 
            device</span><span class="s2">, final </span><span class="s1">String socketType) { 
        Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;connected, Socket Type:&quot; </span><span class="s1">+ socketType)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Cancel the thread that completed the connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mConnectThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s4">// Cancel any thread currently running a connection</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mConnectedThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectedThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectedThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s4">// Cancel the accept thread because we only want to connect to one device</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">(mSecureAcceptThread != </span><span class="s2">null</span><span class="s1">) { 
            mSecureAcceptThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mSecureAcceptThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
        </span><span class="s2">if </span><span class="s1">(mInsecureAcceptThread != </span><span class="s2">null</span><span class="s1">) { 
            mInsecureAcceptThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mInsecureAcceptThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s4">// Start the thread to manage the connection and perform transmissions</span><span class="s1"> 
        mConnectedThread = </span><span class="s2">new </span><span class="s1">ConnectedThread(socket</span><span class="s2">, </span><span class="s1">socketType)</span><span class="s2">;</span><span class="s1"> 
        mConnectedThread.start()</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Send the name of the connected device back to the UI Activity</span><span class="s1"> 
        Message msg = mHandler.obtainMessage(Constants.MESSAGE_DEVICE_NAME)</span><span class="s2">;</span><span class="s1"> 
        Bundle bundle = </span><span class="s2">new </span><span class="s1">Bundle()</span><span class="s2">;</span><span class="s1"> 
        bundle.putString(Constants.DEVICE_NAME</span><span class="s2">, </span><span class="s1">device.getName())</span><span class="s2">;</span><span class="s1"> 
        msg.setData(bundle)</span><span class="s2">;</span><span class="s1"> 
        mHandler.sendMessage(msg)</span><span class="s2">;</span><span class="s1"> 
 
        setState(STATE_CONNECTED)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Stop all threads 
     */</span><span class="s1"> 
    </span><span class="s2">public synchronized void </span><span class="s1">stop() { 
        Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;stop&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s2">if </span><span class="s1">(mConnectThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">(mConnectedThread != </span><span class="s2">null</span><span class="s1">) { 
            mConnectedThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mConnectedThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">(mSecureAcceptThread != </span><span class="s2">null</span><span class="s1">) { 
            mSecureAcceptThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mSecureAcceptThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
 
        </span><span class="s2">if </span><span class="s1">(mInsecureAcceptThread != </span><span class="s2">null</span><span class="s1">) { 
            mInsecureAcceptThread.cancel()</span><span class="s2">;</span><span class="s1"> 
            mInsecureAcceptThread = </span><span class="s2">null;</span><span class="s1"> 
        } 
        setState(STATE_NONE)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Write to the ConnectedThread in an unsynchronized manner 
     * 
     * @param out The bytes to write 
     * @see ConnectedThread#write(byte[]) 
     */</span><span class="s1"> 
    </span><span class="s2">public void </span><span class="s1">write(</span><span class="s2">byte</span><span class="s1">[] out) { 
        </span><span class="s4">// Create temporary object</span><span class="s1"> 
        ConnectedThread r</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s4">// Synchronize a copy of the ConnectedThread</span><span class="s1"> 
        </span><span class="s2">synchronized </span><span class="s1">(</span><span class="s2">this</span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">(mState != STATE_CONNECTED) </span><span class="s2">return;</span><span class="s1"> 
            r = mConnectedThread</span><span class="s2">;</span><span class="s1"> 
        } 
        </span><span class="s4">// Perform the write unsynchronized</span><span class="s1"> 
        r.write(out)</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Indicate that the connection attempt failed and notify the UI Activity. 
     */</span><span class="s1"> 
    </span><span class="s2">private void </span><span class="s1">connectionFailed() { 
        </span><span class="s4">// Send a failure message back to the Activity</span><span class="s1"> 
        Message msg = mHandler.obtainMessage(Constants.MESSAGE_TOAST)</span><span class="s2">;</span><span class="s1"> 
        Bundle bundle = </span><span class="s2">new </span><span class="s1">Bundle()</span><span class="s2">;</span><span class="s1"> 
        bundle.putString(Constants.TOAST</span><span class="s2">, </span><span class="s5">&quot;Unable to connect device&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        msg.setData(bundle)</span><span class="s2">;</span><span class="s1"> 
        mHandler.sendMessage(msg)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Start the service over to restart listening mode</span><span class="s1"> 
        BluetoothChatService.</span><span class="s2">this</span><span class="s1">.start()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * Indicate that the connection was lost and notify the UI Activity. 
     */</span><span class="s1"> 
    </span><span class="s2">private void </span><span class="s1">connectionLost() { 
        </span><span class="s4">// Send a failure message back to the Activity</span><span class="s1"> 
        Message msg = mHandler.obtainMessage(Constants.MESSAGE_TOAST)</span><span class="s2">;</span><span class="s1"> 
        Bundle bundle = </span><span class="s2">new </span><span class="s1">Bundle()</span><span class="s2">;</span><span class="s1"> 
        bundle.putString(Constants.TOAST</span><span class="s2">, </span><span class="s5">&quot;Device connection was lost&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
        msg.setData(bundle)</span><span class="s2">;</span><span class="s1"> 
        mHandler.sendMessage(msg)</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s4">// Start the service over to restart listening mode</span><span class="s1"> 
        BluetoothChatService.</span><span class="s2">this</span><span class="s1">.start()</span><span class="s2">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">/** 
     * This thread runs while listening for incoming connections. It behaves 
     * like a server-side client. It runs until a connection is accepted 
     * (or until cancelled). 
     */</span><span class="s1"> 
    </span><span class="s2">private class </span><span class="s1">AcceptThread </span><span class="s2">extends </span><span class="s1">Thread { 
        </span><span class="s4">// The local server socket</span><span class="s1"> 
        </span><span class="s2">private final </span><span class="s1">BluetoothServerSocket mmServerSocket</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">private </span><span class="s1">String mSocketType</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s2">public </span><span class="s1">AcceptThread(</span><span class="s2">boolean </span><span class="s1">secure) { 
            BluetoothServerSocket tmp = </span><span class="s2">null;</span><span class="s1"> 
            mSocketType = secure ? </span><span class="s5">&quot;Secure&quot; </span><span class="s1">: </span><span class="s5">&quot;Insecure&quot;</span><span class="s2">;</span><span class="s1"> 
 
            </span><span class="s4">// Create a new listening server socket</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s2">if </span><span class="s1">(secure) { 
                    tmp = mAdapter.listenUsingRfcommWithServiceRecord(NAME_SECURE</span><span class="s2">,</span><span class="s1"> 
                            MY_UUID_SECURE)</span><span class="s2">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    tmp = mAdapter.listenUsingInsecureRfcommWithServiceRecord( 
                            NAME_INSECURE</span><span class="s2">, </span><span class="s1">MY_UUID_INSECURE)</span><span class="s2">;</span><span class="s1"> 
                } 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type: &quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot;listen() failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
            mmServerSocket = tmp</span><span class="s2">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">public void </span><span class="s1">run() { 
            Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type: &quot; </span><span class="s1">+ mSocketType + 
                    </span><span class="s5">&quot;BEGIN mAcceptThread&quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            setName(</span><span class="s5">&quot;AcceptThread&quot; </span><span class="s1">+ mSocketType)</span><span class="s2">;</span><span class="s1"> 
 
            BluetoothSocket socket = </span><span class="s2">null;</span><span class="s1"> 
 
            </span><span class="s4">// Listen to the server socket if we're not connected</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">(mState != STATE_CONNECTED) { 
                </span><span class="s2">try </span><span class="s1">{ 
                    </span><span class="s4">// This is a blocking call and will only return on a</span><span class="s1"> 
                    </span><span class="s4">// successful connection or an exception</span><span class="s1"> 
                    socket = mmServerSocket.accept()</span><span class="s2">;</span><span class="s1"> 
                } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                    Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type: &quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot;accept() failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
                    </span><span class="s2">break;</span><span class="s1"> 
                } 
 
                </span><span class="s4">// If a connection was accepted</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">(socket != </span><span class="s2">null</span><span class="s1">) { 
                    </span><span class="s2">synchronized </span><span class="s1">(BluetoothChatService.</span><span class="s2">this</span><span class="s1">) { 
                        </span><span class="s2">switch </span><span class="s1">(mState) { 
                            </span><span class="s2">case </span><span class="s1">STATE_LISTEN: 
                            </span><span class="s2">case </span><span class="s1">STATE_CONNECTING: 
                                </span><span class="s4">// Situation normal. Start the connected thread.</span><span class="s1"> 
                                connected(socket</span><span class="s2">, </span><span class="s1">socket.getRemoteDevice()</span><span class="s2">,</span><span class="s1"> 
                                        mSocketType)</span><span class="s2">;</span><span class="s1"> 
                                </span><span class="s2">break;</span><span class="s1"> 
                            </span><span class="s2">case </span><span class="s1">STATE_NONE: 
                            </span><span class="s2">case </span><span class="s1">STATE_CONNECTED: 
                                </span><span class="s4">// Either not ready or already connected. Terminate new socket.</span><span class="s1"> 
                                </span><span class="s2">try </span><span class="s1">{ 
                                    socket.close()</span><span class="s2">;</span><span class="s1"> 
                                } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                                    Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Could not close unwanted socket&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
                                } 
                                </span><span class="s2">break;</span><span class="s1"> 
                        } 
                    } 
                } 
            } 
            Log.i(TAG</span><span class="s2">, </span><span class="s5">&quot;END mAcceptThread, socket Type: &quot; </span><span class="s1">+ mSocketType)</span><span class="s2">;</span><span class="s1"> 
 
        } 
 
        </span><span class="s2">public void </span><span class="s1">cancel() { 
            Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type&quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot;cancel &quot; </span><span class="s1">+ </span><span class="s2">this</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                mmServerSocket.close()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type&quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot;close() of server failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
        } 
    } 
 
 
    </span><span class="s3">/** 
     * This thread runs while attempting to make an outgoing connection 
     * with a device. It runs straight through; the connection either 
     * succeeds or fails. 
     */</span><span class="s1"> 
    </span><span class="s2">private class </span><span class="s1">ConnectThread </span><span class="s2">extends </span><span class="s1">Thread { 
        </span><span class="s2">private final </span><span class="s1">BluetoothSocket mmSocket</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">private final </span><span class="s1">BluetoothDevice mmDevice</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">private </span><span class="s1">String mSocketType</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s2">public </span><span class="s1">ConnectThread(BluetoothDevice device</span><span class="s2">, boolean </span><span class="s1">secure) { 
            mmDevice = device</span><span class="s2">;</span><span class="s1"> 
            BluetoothSocket tmp = </span><span class="s2">null;</span><span class="s1"> 
            mSocketType = secure ? </span><span class="s5">&quot;Secure&quot; </span><span class="s1">: </span><span class="s5">&quot;Insecure&quot;</span><span class="s2">;</span><span class="s1"> 
 
            </span><span class="s4">// Get a BluetoothSocket for a connection with the</span><span class="s1"> 
            </span><span class="s4">// given BluetoothDevice</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s2">if </span><span class="s1">(secure) { 
                    tmp = device.createRfcommSocketToServiceRecord( 
                            MY_UUID_SECURE)</span><span class="s2">;</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    tmp = device.createInsecureRfcommSocketToServiceRecord( 
                            MY_UUID_INSECURE)</span><span class="s2">;</span><span class="s1"> 
                } 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Socket Type: &quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot;create() failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
            mmSocket = tmp</span><span class="s2">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">public void </span><span class="s1">run() { 
            Log.i(TAG</span><span class="s2">, </span><span class="s5">&quot;BEGIN mConnectThread SocketType:&quot; </span><span class="s1">+ mSocketType)</span><span class="s2">;</span><span class="s1"> 
            setName(</span><span class="s5">&quot;ConnectThread&quot; </span><span class="s1">+ mSocketType)</span><span class="s2">;</span><span class="s1"> 
 
            </span><span class="s4">// Always cancel discovery because it will slow down a connection</span><span class="s1"> 
            mAdapter.cancelDiscovery()</span><span class="s2">;</span><span class="s1"> 
 
            </span><span class="s4">// Make a connection to the BluetoothSocket</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                </span><span class="s4">// This is a blocking call and will only return on a</span><span class="s1"> 
                </span><span class="s4">// successful connection or an exception</span><span class="s1"> 
                mmSocket.connect()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                </span><span class="s4">// Close the socket</span><span class="s1"> 
                </span><span class="s2">try </span><span class="s1">{ 
                    mmSocket.close()</span><span class="s2">;</span><span class="s1"> 
                } </span><span class="s2">catch </span><span class="s1">(IOException e2) { 
                    Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;unable to close() &quot; </span><span class="s1">+ mSocketType + 
                            </span><span class="s5">&quot; socket during connection failure&quot;</span><span class="s2">, </span><span class="s1">e2)</span><span class="s2">;</span><span class="s1"> 
                } 
                connectionFailed()</span><span class="s2">;</span><span class="s1"> 
                </span><span class="s2">return;</span><span class="s1"> 
            } 
 
            </span><span class="s4">// Reset the ConnectThread because we're done</span><span class="s1"> 
            </span><span class="s2">synchronized </span><span class="s1">(BluetoothChatService.</span><span class="s2">this</span><span class="s1">) { 
                mConnectThread = </span><span class="s2">null;</span><span class="s1"> 
            } 
 
            </span><span class="s4">// Start the connected thread</span><span class="s1"> 
            connected(mmSocket</span><span class="s2">, </span><span class="s1">mmDevice</span><span class="s2">, </span><span class="s1">mSocketType)</span><span class="s2">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">public void </span><span class="s1">cancel() { 
            </span><span class="s2">try </span><span class="s1">{ 
                mmSocket.close()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;close() of connect &quot; </span><span class="s1">+ mSocketType + </span><span class="s5">&quot; socket failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s3">/** 
     * This thread runs during a connection with a remote device. 
     * It handles all incoming and outgoing transmissions. 
     */</span><span class="s1"> 
    </span><span class="s2">private class </span><span class="s1">ConnectedThread </span><span class="s2">extends </span><span class="s1">Thread { 
        </span><span class="s2">private final </span><span class="s1">BluetoothSocket mmSocket</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">private final </span><span class="s1">InputStream mmInStream</span><span class="s2">;</span><span class="s1"> 
        </span><span class="s2">private final </span><span class="s1">OutputStream mmOutStream</span><span class="s2">;</span><span class="s1"> 
 
        </span><span class="s2">public </span><span class="s1">ConnectedThread(BluetoothSocket socket</span><span class="s2">, </span><span class="s1">String socketType) { 
            Log.d(TAG</span><span class="s2">, </span><span class="s5">&quot;create ConnectedThread: &quot; </span><span class="s1">+ socketType)</span><span class="s2">;</span><span class="s1"> 
            mmSocket = socket</span><span class="s2">;</span><span class="s1"> 
            InputStream tmpIn = </span><span class="s2">null;</span><span class="s1"> 
            OutputStream tmpOut = </span><span class="s2">null;</span><span class="s1"> 
 
            </span><span class="s4">// Get the BluetoothSocket input and output streams</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                tmpIn = socket.getInputStream()</span><span class="s2">;</span><span class="s1"> 
                tmpOut = socket.getOutputStream()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;temp sockets not created&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
 
            mmInStream = tmpIn</span><span class="s2">;</span><span class="s1"> 
            mmOutStream = tmpOut</span><span class="s2">;</span><span class="s1"> 
        } 
 
        </span><span class="s2">public void </span><span class="s1">run() { 
            Log.i(TAG</span><span class="s2">, </span><span class="s5">&quot;BEGIN mConnectedThread&quot;</span><span class="s1">)</span><span class="s2">;</span><span class="s1"> 
            </span><span class="s2">byte</span><span class="s1">[] buffer = </span><span class="s2">new byte</span><span class="s1">[</span><span class="s6">1024</span><span class="s1">]</span><span class="s2">;</span><span class="s1"> 
            </span><span class="s2">int </span><span class="s1">bytes</span><span class="s2">;</span><span class="s1"> 
 
            </span><span class="s4">// Keep listening to the InputStream while connected</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">(</span><span class="s2">true</span><span class="s1">) { 
                </span><span class="s2">try </span><span class="s1">{ 
                    </span><span class="s4">// Read from the InputStream</span><span class="s1"> 
                    bytes = mmInStream.read(buffer)</span><span class="s2">;</span><span class="s1"> 
 
                    </span><span class="s4">// Send the obtained bytes to the UI Activity</span><span class="s1"> 
                    mHandler.obtainMessage(Constants.MESSAGE_READ</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">buffer) 
                            .sendToTarget()</span><span class="s2">;</span><span class="s1"> 
                } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                    Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;disconnected&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
                    connectionLost()</span><span class="s2">;</span><span class="s1"> 
                    </span><span class="s4">// Start the service over to restart listening mode</span><span class="s1"> 
                    BluetoothChatService.</span><span class="s2">this</span><span class="s1">.start()</span><span class="s2">;</span><span class="s1"> 
                    </span><span class="s2">break;</span><span class="s1"> 
                } 
            } 
        } 
 
        </span><span class="s3">/** 
         * Write to the connected OutStream. 
         * 
         * @param buffer The bytes to write 
         */</span><span class="s1"> 
        </span><span class="s2">public void </span><span class="s1">write(</span><span class="s2">byte</span><span class="s1">[] buffer) { 
            </span><span class="s2">try </span><span class="s1">{ 
                mmOutStream.write(buffer)</span><span class="s2">;</span><span class="s1"> 
 
                </span><span class="s4">// Share the sent message back to the UI Activity</span><span class="s1"> 
                mHandler.obtainMessage(Constants.MESSAGE_WRITE</span><span class="s2">, </span><span class="s1">-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">buffer) 
                        .sendToTarget()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;Exception during write&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
        } 
 
        </span><span class="s2">public void </span><span class="s1">cancel() { 
            </span><span class="s2">try </span><span class="s1">{ 
                mmSocket.close()</span><span class="s2">;</span><span class="s1"> 
            } </span><span class="s2">catch </span><span class="s1">(IOException e) { 
                Log.e(TAG</span><span class="s2">, </span><span class="s5">&quot;close() of connect socket failed&quot;</span><span class="s2">, </span><span class="s1">e)</span><span class="s2">;</span><span class="s1"> 
            } 
        } 
    } 
} 
</span></pre>
</body>
</html>